3.1 - Looking at processes:
Cada programa é executado a partir de um ou mais processos, cada um com um ID único durante a execução. Os processos são criados por outros processos, formando uma árvore de processos, onde o processo "init" é o primeiro. Para listar o ID do processo e o ID do processo pai, podemos utilizar comandos específicos. Um processo pode ser encerrado usando o comando "kill", que envia um sinal de término para o processo. Isso é conhecido como SIGTERM.

3.2 - Creating Processes
Para criar um processo, podemos usar a linguagem C e executar o comando "system", ou podemos clonar um processo usando o comando "fork". O comando "exec" substitui o programa em execução em um processo. Podemos combinar "exec" e "fork" para criar uma cópia do processo e substituir o programa em execução, ou seja, podemos criar outro processo com um programa diferente. Para isso, utilizamos o comando "spawn", fornecendo o comando principal e uma lista de argumentos para execução. Podemos solicitar a execução de processos e determinar a ordem de execução usando o comando "nice", onde um número positivo indica menor prioridade e um número negativo indica maior prioridade. Isso nos permite dar mais agilidade a um processo solicitado ou menor prioridade a um processo conhecido por ser mais lento. Além disso, o comando "renice" permite alterar a prioridade de um programa que já está em execução.

3.3 - Signals:
Os sinais são usados para modificar a execução de um processo, como interrompê-lo. Para lidar com sinais, existem os "signal handlers", que pausam a execução do programa, executam o sinal e, em seguida, retornam à execução normal. Como os processos são assíncronos, o programa principal pode ser afetado quando um sinal é recebido e processado enquanto um verificador de sinal está em execução. É recomendado evitar operações de entrada/saída e chamadas a bibliotecas e funções durante o processamento de "signal handlers".

3.4 – Process Termination
Para finalizar um processo, basta que o próprio programa chame a função "exit". Além disso, é possível encerrar processos de forma "irregular" usando sinais de finalização. Também temos os "processos zumbis": quando um processo filho é encerrado enquanto o processo pai está esperando pelo seu término usando a função "wait", o processo filho é encerrado e retorna um código de status relacionado ao seu término para o processo pai. Se um processo filho for encerrado sem o processo pai esperar seu término usando a função "wait", ele se torna um "processo zumbi". Em outras palavras, um processo zumbi é um processo que foi encerrado, mas ainda não foi completamente removido. A responsabilidade de remover o processo filho é do processo pai.
